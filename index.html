<!DOCTYPE html><html lang="de"><head>  <meta charset="utf-8">
  <title>Flugspur App mit Höhen-Offset</title>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.119/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.119/Build/Cesium/Cesium.js"></script>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; width: 100%; font-family: sans-serif; background: #f0f0f0; overflow: hidden; }
    #cesiumContainer { position: absolute; top: 0px; left: 0; width: 100%; height: 70%; }
    #chartContainer { position: absolute; bottom: 0; left: 0; width: 100%; height: 30%; background: #D3D3D3; padding: 10px; box-sizing: border-box; }#mainChart { width: 100%; height: 100%; }
button, select, input[type="range"] { touch-action: manipulation;
}

#buttonBar { position: fixed; bottom: 1%; left: 10px; right: 10px; display: flex; flex-wrap: wrap; gap: 16px; justify-content: flex-start; z-index: 2000; }

#buttonBar > * { background: #333; color: white; padding: 10px 15px; border: none; border-radius: 20px; font-size: 14px; box-shadow: 0 2px 5px rgba(0,0,0,0.4); touch-action: manipulation; }

#trailSlider { width: 100px; }

#fileInput { display: none; }

.cesium-button { transform: scale(2); transform-origin: top left; margin-bottom: 12px; /* zusätzlicher Abstand zwischen Buttons */ }

.cesium-viewer-toolbar { top: 30px !important; right: 30px !important; display: flex; flex-direction: column; gap: 12px; /* moderner Abstand zwischen Buttons */ }

#infoBox { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.6); color: white; padding: 8px 12px; border-radius: 10px; font-size: 25px; z-index: 1000; pointer-events: none;

} #infoBox strong { font-weight: bold; }

  </style>
</head><body><div id="buttonBar">
  <button id="switchView">Wechsel zu 3D</button>
 <button id="openFile">Datei auswählen</button>
<div id="fileOptionsDialog" style="display: none; position: fixed; top: 30%; left: 50%; transform: translateX(-50%); background: white; padding: 20px; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); z-index: 3000;">
  <p>Was möchtest du tun?</p>
  <button id="loadLocalBtn">Lokal laden</button>
  <button id="loadServerBtn">Vom Server laden</button>
  <div id="serverFileDialog" style="display: none; position: fixed; top: 25%; left: 50%; transform: translateX(-50%); background: white; padding: 20px; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); z-index: 3000;">
  <p>Verfügbare Dateien auf dem Server:</p>
  <div id="serverFileList" style="display: flex; flex-direction: column; gap: 10px;"></div>
  <button onclick="document.getElementById('serverFileDialog').style.display='none'">Abbrechen</button>
</div>
  <button id="uploadServerBtn">Auf Server speichern</button>
  <button onclick="document.getElementById('fileOptionsDialog').style.display='none'">Abbrechen</button>
</div>
<input type="file" id="fileInput" accept=".kml">
  <button id="startBtn">Start</button>
  <button id="pauseBtn">Pause</button>
  <button id="rewindBtn">Zurück</button>
  <input type="range" id="trailSlider" min="10" max="1000" value="80">
  <select id="speedSelect">
    <option value="1">1x</option>
    <option value="2">2x</option>
    <option value="4">4x</option>
    <option value="8">8x</option>
  </select>
  <button id="toggleFollow">Kamera folgt: AN</button>
</div>
<input type="file" id="fileInput" accept=".kml">
<div id="cesiumContainer"></div>
<div id="infoBox">
  <div><strong>Geschwindigkeit:</strong> <span id="infoSpeed">–</span> km/h</div>
  <div><strong>Höhe (NN):</strong> <span id="infoAlt">–</span> m</div>
  <div><strong>Höhe über Start:</strong> <span id="infoRelAlt">–</span> m</div>
<div><strong>Steigrate:</strong> <span id="infoVario">–</span> m/s</div>
</div>
<div id="chartContainer"><canvas id="mainChart"></canvas></div><script>
Cesium.Ion.defaultAccessToken  = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI5ZTI3MDRmMy1mYjg5LTRjNmYtYjBmZC1kZDQxN2NlNzVkZDEiLCJpZCI6Mjk3NzA1LCJpYXQiOjE3NDU5MzE5MTh9.svRycz7t606srY9WbWiWUaLB2hJpycWmo835Dy-VWtw';

let startAltitude = null;
const altitudeOffset = 38;
const viewer = new Cesium.Viewer('cesiumContainer', {
  sceneMode: Cesium.SceneMode.SCENE2D,
  animation: false,
  timeline: false,
  baseLayerPicker: true,     // nur dieser bleibt
  fullscreenButton: false,
  homeButton: false,
  sceneModePicker: false,
  geocoder: true,
  navigationHelpButton: false,
  infoBox: false,
  selectionIndicator: false,
  terrainProvider: undefined
});
const controller = viewer.scene.screenSpaceCameraController;
controller.rotateRate = 0.3;          // Kamera-Rotation
controller.zoomEventTypes = [
  Cesium.CameraEventType.WHEEL,
  Cesium.CameraEventType.PINCH
];
controller.zoomRate = 0.5;            // Zoom-Empfindlichkeit
controller.tiltRate = 0.3;            // Neigungsrate (nur in 3D relevant)

let lastQuadTime = null;

let verticalQuadEntities = [];
let verticalLineEntities = [];

let fullCoords = [], animationIndex = 0, animationInterval = null;
let mainChart, is3D = false, speedFactor = 1, trailSeconds = 60, followEnabled = true;
let movingPointEntity = null, followTransform;

const trailPositions = new Cesium.CallbackProperty(() => {
  const t = fullCoords[animationIndex]?.seconds ?? 0;
  const trail = fullCoords.filter(p => p.seconds >= t - trailSeconds && p.seconds <= t);
  return Cesium.Cartesian3.fromDegreesArrayHeights(
    trail.flatMap(p => [p.lon, p.lat, p.alt + altitudeOffset])
  );
}, false);

viewer.entities.add({
  polyline: {
    positions: trailPositions,
    width: 12,
    material: new Cesium.PolylineGlowMaterialProperty({
      glowPower: 1.0,          // wie stark es leuchtet (0.0–1.0)

      color: Cesium.Color.BLUE.withAlpha(0.9)
    })
  }
});

async function updateMovingPoint(p) {
  const pos = Cesium.Cartesian3.fromDegrees(p.lon, p.lat, p.alt + altitudeOffset);

  if (!movingPointEntity) {
    movingPointEntity = viewer.entities.add({
      position: pos,
      orientation: new Cesium.CallbackProperty(() => {
        if (animationIndex === 0 || animationIndex >= fullCoords.length) return Cesium.Quaternion.IDENTITY;

        const prev = fullCoords[animationIndex - 1];
        const curr = fullCoords[animationIndex];

        const from = Cesium.Cartesian3.fromDegrees(prev.lon, prev.lat, prev.alt + altitudeOffset);
        const to = Cesium.Cartesian3.fromDegrees(curr.lon, curr.lat, curr.alt + altitudeOffset);

        const dir = Cesium.Cartesian3.subtract(to, from, new Cesium.Cartesian3());
        if (Cesium.Cartesian3.magnitude(dir) === 0) return Cesium.Quaternion.IDENTITY;

        Cesium.Cartesian3.normalize(dir, dir);
        const up = Cesium.Cartesian3.UNIT_Z;
        const right = Cesium.Cartesian3.cross(up, dir, new Cesium.Cartesian3());
        Cesium.Cartesian3.normalize(right, right);
        const trueUp = Cesium.Cartesian3.cross(dir, right, new Cesium.Cartesian3());

        const rotMatrix = new Cesium.Matrix3();
        Cesium.Matrix3.setColumn(rotMatrix, 0, right, rotMatrix);
        Cesium.Matrix3.setColumn(rotMatrix, 1, trueUp, rotMatrix);
        Cesium.Matrix3.setColumn(rotMatrix, 2, dir, rotMatrix);

        const baseQuat = Cesium.Quaternion.fromRotationMatrix(rotMatrix);

        // zusätzliche feste Rotation (z. B. -90° um X-Achse)
        const correctionQuat = Cesium.Quaternion.fromAxisAngle(Cesium.Cartesian3.UNIT_Y, Cesium.Math.toRadians(-20));
        

        return Cesium.Quaternion.multiply(baseQuat, correctionQuat, new Cesium.Quaternion());
      }, false),
      model: {
        uri: 'https://benne1994.github.io/Flugroute/falcon.glb',
        scale: 0.002,
        minimumPixelSize: 32
      }
    });

    if (followEnabled) enableFollow(p);
  } else {
    movingPointEntity.position = pos;
    if (followEnabled) updateFollow(p);
  }

  // Zeitabweichung prüfen und ggf. Flächen zurücksetzen
  const currentTime = p.seconds;
  if (lastQuadTime !== null && Math.abs(currentTime - lastQuadTime) > 10) {
    verticalQuadEntities.forEach(ent => viewer.entities.remove(ent));
    verticalQuadEntities = [];
  }
  lastQuadTime = currentTime;

  // Geschwindigkeitsanzeige + Höhenanzeige aktualisieren
  let speedKmh = 0;
  if (animationIndex > 0) {
    const prev = fullCoords[animationIndex - 1];
    const dx = p.lon - prev.lon;
    const dy = p.lat - prev.lat;
    const dist = Math.sqrt(dx * dx + dy * dy) * 111320;
    const dt = p.seconds - prev.seconds;
    if (dt > 0) speedKmh = (dist / dt) * 3.6;
  }

  if (startAltitude === null) startAltitude = p.alt;

  let climbRate = 0;
  if (animationIndex > 0) {
    const prev = fullCoords[animationIndex - 1];
    const dt = p.seconds - prev.seconds;
    if (dt > 0) climbRate = (p.alt - prev.alt) / dt;
  }

  document.getElementById('infoSpeed').textContent = speedKmh.toFixed(1);
  document.getElementById('infoAlt').textContent = p.alt.toFixed(1);
  document.getElementById('infoRelAlt').textContent = (p.alt - startAltitude).toFixed(1);
  document.getElementById('infoVario').textContent = climbRate.toFixed(1);
}





 
 async function createVerticalQuad(p1, p2) {
  const baseColor = Cesium.Color.fromCssColorString("#6699FF"); // helleres Blau

  // Terrains für beide Punkte abfragen
  const cartos = [
    Cesium.Cartographic.fromDegrees(p1.lon, p1.lat),
    Cesium.Cartographic.fromDegrees(p2.lon, p2.lat)
  ];
  const updated = await Cesium.sampleTerrainMostDetailed(viewer.terrainProvider, cartos);
  const ground1Height = updated[0].height ?? 0;
  const ground2Height = updated[1].height ?? 0;

  const top1 = Cesium.Cartesian3.fromDegrees(p1.lon, p1.lat, p1.alt + altitudeOffset);
  const top2 = Cesium.Cartesian3.fromDegrees(p2.lon, p2.lat, p2.alt + altitudeOffset);
  const ground1 = Cesium.Cartesian3.fromDegrees(p1.lon, p1.lat, ground1Height);
  const ground2 = Cesium.Cartesian3.fromDegrees(p2.lon, p2.lat, ground2Height);

  const entity = viewer.entities.add({
    polygon: {
      hierarchy: new Cesium.PolygonHierarchy([top1, top2, ground2, ground1]),
      material: baseColor.withAlpha(0.15),
      perPositionHeight: true
    }
  });

  verticalQuadEntities.push(entity);

  if (verticalQuadEntities.length > 50) {
    const removed = verticalQuadEntities.shift();
    viewer.entities.remove(removed);
  }

  verticalQuadEntities.forEach((ent, i) => {
    const alpha = 0.15 + (i / verticalQuadEntities.length) * 0.35;
    ent.polygon.material = baseColor.withAlpha(alpha);
  });
}
 
 
 
 
 
 


function enableFollow(p) {
  const pos = Cesium.Cartesian3.fromDegrees(p.lon, p.lat, p.alt + altitudeOffset);
  const offset = new Cesium.Cartesian3(0, -1000, 500);
  followTransform = Cesium.Transforms.eastNorthUpToFixedFrame(pos);
  viewer.camera.lookAtTransform(followTransform, offset);
}

function updateFollow(p) {
  const pos = Cesium.Cartesian3.fromDegrees(p.lon, p.lat, p.alt + altitudeOffset);
  followTransform = Cesium.Transforms.eastNorthUpToFixedFrame(pos);
  viewer.camera.lookAtTransform(followTransform, viewer.camera.position); // nur Position bleibt erhalten
}

function stopFollow() {
  viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
}

async function loadFromServer(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) throw new Error("Fehler beim Laden");
    const text = await response.text();
    const lines = text.split(/\r?\n/);
    fullCoords = []; let currentTime = null;
    for (let line of lines) {
      line = line.trim();
      if (line.startsWith('<name>')) {
        const [h,m,s] = line.replace(/<\/?name>/g,'').trim().split(':').map(Number);
        currentTime = h*3600 + m*60 + s;
      }
      if (line.includes('<coordinates>')) {
        const [lon, lat, alt] = line.substring(line.indexOf('>')+1, line.indexOf('</coordinates>')).trim().split(',').map(Number);
        if (currentTime !== null) {
          if (fullCoords.length > 0) {
            const last = fullCoords[fullCoords.length - 1];
            const steps = 10;
            for (let i = 1; i < steps; i++) {
              const t = i / steps;
              fullCoords.push({
                seconds: last.seconds + (currentTime - last.seconds) * t,
                lon: last.lon + (lon - last.lon) * t,
                lat: last.lat + (lat - last.lat) * t,
                alt: last.alt + (alt - last.alt) * t
              });
            }
          }
          fullCoords.push({ seconds: currentTime, lon, lat, alt });
        }
      }
    }
    if (fullCoords.length > 0) {
      animationIndex = 0;
      updateMovingPoint(fullCoords[0]);
      createChart();
    }
  } catch (err) {
    alert("Fehler beim Laden der Datei: " + err.message);
  }
}

async function startAnimation() {
  clearInterval(animationInterval);
  animationInterval = setInterval(async () => {
    if (animationIndex >= fullCoords.length - 1) {
      clearInterval(animationInterval);
      return;
    }

    const prevTime = fullCoords[animationIndex]?.seconds ?? 0;
    animationIndex++;
    const currentPoint = fullCoords[animationIndex];

    await updateMovingPoint(currentPoint);

    // Alle 3 Schritte Fläche zwischen Flugspur und Terrain erzeugen
    if (animationIndex % 8 === 0 && animationIndex > 0) {
      await createVerticalQuad(fullCoords[animationIndex - 1], currentPoint);
    }

    updateChartMarker();
  }, 1000 / (speedFactor * 10));
}


function createChart() {
  const ctx = document.getElementById('mainChart').getContext('2d');
  const seconds = fullCoords.map(p => p.seconds);
  const alt = fullCoords.map(p => p.alt);
  const speeds = [0];
  for (let i = 1; i < fullCoords.length; i++) {
    const dx = fullCoords[i].lon - fullCoords[i - 1].lon;
    const dy = fullCoords[i].lat - fullCoords[i - 1].lat;
    const dist = Math.sqrt(dx*dx + dy*dy) * 111320;
    const dt = fullCoords[i].seconds - fullCoords[i - 1].seconds;
    speeds.push(dt > 0 ? (dist/dt)*3.6 : 0);
  }

  if (mainChart) mainChart.destroy();
  mainChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: seconds,
      datasets: [
        { label: 'Höhe (m)', data: alt, borderColor: 'blue', yAxisID: 'y1', pointRadius: 0, tension: 0.2 },
        { label: 'Geschwindigkeit (km/h)', data: speeds, borderColor: 'green', yAxisID: 'y2', pointRadius: 0, tension: 0.2 }
      ]
    },
    options: {
      responsive: true,
      animation: false,
      plugins: {
        legend: { display: true },
        annotation: {
          annotations: {
            currentLine: {
              type: 'line',
              xMin: seconds[0],
              xMax: seconds[0],
              borderColor: 'red',
              borderWidth: 2,
              label: {
                display: true,
                content: ctx => {
                  const sec = fullCoords[animationIndex]?.seconds ?? 0;
                  const h = Math.floor(sec / 3600);
                  const m = Math.floor((sec % 3600) / 60);
                  const s = Math.floor(sec % 60);
                  return h > 0
                    ? `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`
                    : `${m}:${s.toString().padStart(2, '0')}`;
                },
                backgroundColor: 'red',
                color: 'white',
                font: { weight: 'bold' },
                position: 'start'
              }
            }
          }
        }
      },
      onClick: async (event) => {
        const points = mainChart.getElementsAtEventForMode(event, 'nearest', { intersect: false }, false);
        if (points.length > 0) {
          const index = points[0].index;
          animationIndex = index;
          await updateMovingPoint(fullCoords[animationIndex]);
          updateChartMarker();
        }
      },
      scales: {
        x: {
          type: 'linear',
          title: { display: true, text: 'Zeit' },
          ticks: {
            callback: function(value) {
              const h = Math.floor(value / 3600);
              const m = Math.floor((value % 3600) / 60);
              const s = Math.floor(value % 60);
              return h > 0
                ? `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`
                : `${m}:${s.toString().padStart(2, '0')}`;
            }
          }
        },
        y1: { type: 'linear', position: 'left', title: { display: true, text: 'Höhe (m)' } },
        y2: { type: 'linear', position: 'right', title: { display: true, text: 'km/h' }, grid: { drawOnChartArea: false } }
      }
    }
  });
}

function updateChartMarker() {
  if (!mainChart) return;
  const seconds = fullCoords[animationIndex]?.seconds ?? 0;
  const annotation = mainChart.options.plugins.annotation.annotations.currentLine;
  annotation.xMin = annotation.xMax = seconds;
  mainChart.update('none');
}



document.getElementById('switchView').onclick = () => {
  is3D = !is3D;
  viewer.scene.mode = is3D ? Cesium.SceneMode.SCENE3D : Cesium.SceneMode.SCENE2D;
  document.getElementById('switchView').textContent = is3D ? 'Wechsel zu 2D' : 'Wechsel zu 3D';
  if (is3D) Cesium.createWorldTerrainAsync().then(t => viewer.terrainProvider = t);
};

document.getElementById('openFile').onclick = () => {
  document.getElementById('fileOptionsDialog').style.display = 'block';
};

document.getElementById('loadLocalBtn').onclick = () => {
  document.getElementById('fileOptionsDialog').style.display = 'none';
  setTimeout(() => {
    const fileInput = document.getElementById('fileInput');
    fileInput.value = '';
    fileInput.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true, view: window }));
  }, 100);
};



document.getElementById('loadServerBtn').onclick = async () => {
  document.getElementById('fileOptionsDialog').style.display = 'none';

  try {
    const response = await fetch('https://flugspur-backend.onrender.com/list');
    const files = await response.json();
    const listContainer = document.getElementById('serverFileList');
    listContainer.innerHTML = '';
    files.forEach(file => {
      const btn = document.createElement('button');
      btn.textContent = file;
      btn.onclick = async () => {
        document.getElementById('serverFileDialog').style.display = 'none';
        const url = `https://flugspur-backend.onrender.com/uploads/${encodeURIComponent(file)}`;
        await loadFromServer(url);
      };
      listContainer.appendChild(btn);
    });
    document.getElementById('serverFileDialog').style.display = 'block';
  } catch (err) {
    alert("Fehler beim Abrufen der Dateiliste");
  }
};



document.getElementById('uploadServerBtn').onclick = async () => {
  document.getElementById('fileOptionsDialog').style.display = 'none';
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.kml';
  input.onchange = async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    const formData = new FormData();
    formData.append('file', file);

    try {
      const response = await fetch('https://flugspur-backend.onrender.com/upload', {
        method: 'POST',
        body: formData
      });
      const text = await response.text();
      alert(text);
    } catch (err) {
      alert("Fehler beim Hochladen: " + err.message);
    }
  };
  input.click();
};





document.getElementById('fileInput').addEventListener('change', function(event) {
  const file = event.target.files[0]; if (!file) return;
  const reader = new FileReader(); reader.onload = function(e) {
    const lines = e.target.result.split(/\r?\n/);
    fullCoords = []; let currentTime = null;
    for (let line of lines) {
      line = line.trim();
      if (line.startsWith('<name>')) {
        const [h,m,s] = line.replace(/<\/?name>/g,'').trim().split(':').map(Number);
        currentTime = h*3600 + m*60 + s;
      }
 
 
 if (line.includes('<coordinates>')) {
  const [lon, lat, alt] = line.substring(line.indexOf('>')+1, line.indexOf('</coordinates>')).trim().split(',').map(Number);
  if (currentTime !== null) {
    if (fullCoords.length > 0) {
      const last = fullCoords[fullCoords.length - 1];
      const steps = 10; // Anzahl der Zwischenpunkte
      for (let i = 1; i < steps; i++) {
        const t = i / steps;
        fullCoords.push({
          seconds: last.seconds + (currentTime - last.seconds) * t,
          lon: last.lon + (lon - last.lon) * t,
          lat: last.lat + (lat - last.lat) * t,
          alt: last.alt + (alt - last.alt) * t
        });
      }
    }
    fullCoords.push({ seconds: currentTime, lon, lat, alt });
  }
}
 
 
 
    }
    if (fullCoords.length > 0) {
      animationIndex = 0;
      updateMovingPoint(fullCoords[0]);
      createChart();
    }
  
  
    };
  reader.readAsText(file);
});

document.getElementById('startBtn').onclick = startAnimation;
document.getElementById('pauseBtn').onclick = () => clearInterval(animationInterval);
document.getElementById('rewindBtn').onclick = () => {
  animationIndex = 0;
  updateMovingPoint(fullCoords[0]);
};
document.getElementById('trailSlider').oninput = e => trailSeconds = parseInt(e.target.value);
document.getElementById('speedSelect').onchange = async e => {
  speedFactor = parseInt(e.target.value);
  if (animationInterval) {
    clearInterval(animationInterval);
    await startAnimation(); // direkt neu starten mit neuer Geschwindigkeit
  }
};

document.getElementById('toggleFollow').onclick = () => {
  followEnabled = !followEnabled;
  document.getElementById('toggleFollow').textContent = followEnabled ? 'Kamera folgt: AN' : 'Kamera folgt: AUS';
  if (!followEnabled) stopFollow();
  else updateMovingPoint(fullCoords[animationIndex]);
updateChartMarker();
};
</script></body></html>
